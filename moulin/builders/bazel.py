# SPDX-License-Identifier: Apache-2.0
# Copyright 2023 EPAM Systems
"""
Bazel builder module
"""

import os.path
from typing import List
from moulin.yaml_wrapper import YamlValue
from moulin import ninja_syntax


def get_builder(conf: YamlValue, name: str, build_dir: str, src_stamps: List[str],
                generator: ninja_syntax.Writer):
    """
    Return configured Bazel class
    """
    return Bazel(conf, name, build_dir, src_stamps, generator)


def gen_build_rules(generator: ninja_syntax.Writer):
    """
    Generate Bazel build rules for ninja
    """
    cmd = " && ".join([
        "cd ${build_dir}",
        "${bazel_build_command}"
    ])
    # For unconditional shutdown of the bazel server
    cmd += "; BUILD_RESULT=$$(echo \\$$?); ${bazel_shutdown_command}; exit \\$${BUILD_RESULT}"
    generator.rule("bazel_build",
                   command=f'bash -c "{cmd}"',
                   description="Invoke Bazel build script",
                   pool="console")
    generator.newline()


class Bazel:
    """
    BazelBuilder class generates Ninja rules for given Bazel build configuration
    """
    def __init__(self, conf: YamlValue, name: str, build_dir: str, src_stamps: List[str],
                 generator: ninja_syntax.Writer):
        self.conf = conf
        self.name = name
        self.generator = generator
        self.src_stamps = src_stamps
        self.build_dir = build_dir
        self.tool: str = conf.get("tool", "bazel").as_str
        self.start_options = conf.get("start-options", None)
        self.command: str = conf.get("command", "build").as_str
        self.args = conf.get("args", None)
        self.target: str = conf["target"].as_str
        self.target_patterns = conf.get("target-patterns", None)

    def gen_build(self):
        """Generate ninja rules to build Bazel"""

        _command: list = []
        _command.append(self.tool)
        if self.start_options:
            _command.extend([x.as_str for x in self.start_options])
        # Auto shutdown server in one second in case of exception or interruption signal during build
        _command.append("--max_idle_secs=1")
        _command.append(self.command)
        if self.args:
            _command.extend([x.as_str for x in self.args])
        _command.append(self.target)
        if self.target_patterns:
            _command.append("--")
            _command.extend([x.as_str for x in self.target_patterns])
        bazel_build_command: str = " ".join(_command)

        bazel_shutdown_command: str = f"{self.tool} shutdown"

        variables = {
            "build_dir": self.build_dir,
            "bazel_build_command": bazel_build_command,
            "bazel_shutdown_command": bazel_shutdown_command
        }
        targets = self.get_targets()
        self.generator.build(targets, "bazel_build", self.src_stamps, variables=variables)
        self.generator.newline()

        return targets

    def get_targets(self):
        "Return list of targets that are generated by this build"
        return [os.path.join(self.build_dir, t.as_str) for t in self.conf["target_images"]]

    def capture_state(self):
        """
        This method should capture Bazel state for a reproducible builds.
        Luckily, there is nothing to do, as Bazel state is controlled solely by
        its repo state. And repo state is captured by repo fetcher code.
        """
