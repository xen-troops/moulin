# SPDX-License-Identifier: Apache-2.0
# Copyright 2021 EPAM Systems
"""
Yocto builder module
"""

import os.path
import shlex
from typing import List, Tuple, cast
from moulin.utils import create_stamp_name, construct_fetcher_dep_cmd
from moulin import ninja_syntax
from moulin.yaml_wrapper import YamlValue
from moulin.yaml_helpers import YAMLProcessingError
import logging
import sys
import subprocess
import argparse
import os
import re
from pathlib import Path


YOCTO_CORE_LAYERS = ["../poky/meta", "../poky/meta-poky", "../poky/meta-yocto-bsp"]
log = logging.getLogger(__name__)


def get_builder(conf: YamlValue, name: str, build_dir: str, src_stamps: List[str],
                generator: ninja_syntax.Writer):
    """
    Return configured YoctoBuilder class
    """
    return YoctoBuilder(conf, name, build_dir, src_stamps, generator)


def gen_build_rules(generator: ninja_syntax.Writer):
    """
    Generate yocto build rules for ninja
    """
    # Create build dir by calling poky/oe-init-build-env script
    cmd = " && ".join([
        "cd $yocto_dir",
        "source poky/oe-init-build-env $work_dir",
    ])
    generator.rule("yocto_init_env",
                   command=f'bash -c "{cmd}"',
                   description="Initialize Yocto build environment",
                   restat=True)
    generator.newline()

    # Minimal CLI: program + build.yaml (utility doesn't need global flags).
    prog = os.path.basename(sys.argv[0])
    conf_path = sys.argv[1]  # предполагаем, что это build.yaml
    base_cli = shlex.join([prog, conf_path])

    # Add and remove bitbake layers use --utility-builders-yocto_set_layers
    cmd = " && ".join([
        f"{base_cli} "
        "--utility-builders-yocto "
        "--yocto-dir $yocto_dir "
        "--work-dir $work_dir "
        "--layers $layers "
        "--stamp $out",
    ])
    generator.rule("yocto_add_layers",
                   command=f'bash -c "{cmd}"',
                   description="Add and remove yocto layers",
                   pool="console",
                   restat=True)
    generator.newline()

    # Write own configuration to moulin.conf. Include it in local.conf
    cmd = " && ".join([
        "cd $yocto_dir",
        "echo '# Code generated by moulin. All manual changes will be lost' > $work_dir/conf/moulin.conf",
        "for x in $conf; do echo $$x >> $work_dir/conf/moulin.conf; done",
        "sed \"/require moulin\\.conf/d\" -i $work_dir/conf/local.conf",
        "echo 'require moulin.conf' >> $work_dir/conf/local.conf",
        "touch -r $work_dir/conf/bblayers.conf $work_dir/conf/local.conf",
    ])
    generator.rule(
        "yocto_update_conf",
        command=cmd,
        description="Update local.conf",
    )
    generator.newline()

    # Invoke bitbake. This rule uses "console" pool so we can see the bitbake output.
    cmd = " && ".join([
        # Generate fetcher dependency file
        construct_fetcher_dep_cmd(),
        "cd $yocto_dir",
        "source poky/oe-init-build-env $work_dir",
        "bitbake $target",
    ])
    generator.rule("yocto_build",
                   command=f'bash -c "{cmd}"',
                   description="Yocto Build: $name",
                   pool="console",
                   deps="gcc",
                   depfile=".moulin_$name.d",
                   restat=True)


def _flatten_yocto_conf(conf: YamlValue) -> List[Tuple[str, str]]:
    """
    Flatten conf entries. While using YAML *entries syntax, we will get list of conf
    entries inside of other list. To overcome this, we need to move inner list 'up'
    """

    # Problem is conf entries that it is list itself
    result: List[Tuple[str, str]] = []
    for entry in conf:
        if not entry.is_list:
            raise YAMLProcessingError("Expected array on 'conf' node", entry.mark)
        if entry[0].is_list:
            result.extend([(x[0].as_str, x[1].as_str) for x in entry])
        else:
            result.append((entry[0].as_str, entry[1].as_str))
    return result


def _flatten_layers(layers_node: YamlValue) -> List[str]:
    """
Flattens a YAML structure representing layers into a list of strings.
This function takes a YAML node representing layers and flattens it into a list of strings.
It processes the input YAML structure, extracting individual layer names as strings and adding
them to the resulting list.
Args:
    layers_node (YamlValue): The YAML node, represents a list of layers.
Returns:
    List[str]: A list of strings, each string represents a layer name.
Example:
    If `layers_node` is a YAML list like this:
    -
     - nested_layer1
     - nested_layer2
    - layer3
    - layer4
    The function will return ['nested_layer1', 'nested_layer2', 'layer3', 'layer4']
"""
    result: List[str] = []
    for entry in layers_node:
        if entry.is_list:
            result.extend([(x.as_str) for x in entry])
        else:
            result.append((entry.as_str))
    return result


def _filter_yocto_core_layers(layers: List[str]) -> List[str]:
    """
By default, Poky adds the following layers:

"meta"
"meta-poky"
"meta-yocto-bsp"

For more details, you can find information about it here:
https://github.com/yoctoproject/poky/blob/807831067405a465886593df4e3057d3846a0001/documentation/
migration-guides/migration-1.3.rst#bblayersconf
and here:
poky/meta-poky/conf/bblayers.conf.sample

This function checks the list of layers in your Yaml configuration. If it finds Poky default layers,
it outputs a corresponding warning to the user. Such layers will be removed from the final list since
Poky adds them by default on its level.

Please, be aware, that the warning in this function will be changed to an exception soon. Please, adapt
your YAML Moulin configuration files.

    Args:
    - _layers (List[str]): A list of layers to filter.

    Returns:
    - List[str]: A filtered list of layers without the ones added by the Poky by default.
"""
    result: List[str] = []
    for layer in layers:
        if layer in YOCTO_CORE_LAYERS:
            log.warning("You explicitly specified the %s layer. This layer is the default layer in Poky."
                        " Please, remove this layer from your YAML configuration.", layer)
        else:
            result.append(layer)
    return result


class YoctoBuilder:
    """
    YoctoBuilder class generates Ninja rules for given build configuration
    """
    def __init__(self, conf: YamlValue, name: str, build_dir: str, src_stamps: List[str],
                 generator: ninja_syntax.Writer):
        self.conf = conf
        self.name = name
        self.generator = generator
        self.src_stamps = src_stamps
        # With yocto builder it is possible to have multiple builds with the same set of
        # layers. Thus, we have two variables - build_dir and work_dir
        # - yocto_dir is the upper directory where layers are stored. Basically, we should
        #   have "poky" in our yocto_dir
        # - work_dir is the build directory where we can find conf/local.conf, tmp and other
        #   directories. It is called "build" by default
        self.yocto_dir = build_dir
        self.work_dir: str = conf.get("work_dir", "build").as_str

    def _get_external_src(self) -> List[Tuple[str, str]]:
        external_src_node = self.conf.get("external_src", None)
        if not external_src_node:
            return []

        ret: List[Tuple[str, str]] = []
        for key, val_node in cast(YamlValue, external_src_node).items():
            if val_node.is_list:
                path = os.path.join(*[x.as_str for x in val_node])
            else:
                path = val_node.as_str
            path = os.path.abspath(path)
            ret.append((f"EXTERNALSRC:pn-{key}", path))

        return ret

    def gen_build(self):
        """Generate ninja rules to build yocto/poky"""
        common_variables = {
            "yocto_dir": self.yocto_dir,
            "work_dir": self.work_dir,
        }

        # First we need to ensure that "conf" dir exists
        env_target = os.path.join(self.yocto_dir, self.work_dir, "conf", "local.conf")
        all_deps = self.src_stamps.copy()
        additional_deps_node = self.conf.get("additional_deps", None)
        if additional_deps_node:
            all_deps.extend(
                os.path.normpath(
                    os.path.join(self.yocto_dir, d.as_str)
                )
                for d in additional_deps_node
            )
        self.generator.build(env_target,
                             "yocto_init_env",
                             all_deps,
                             variables=common_variables)

        # Then we need to add layers
        layers_node = self.conf.get("layers", None)
        if layers_node:
            layers_stamp = create_stamp_name(self.yocto_dir, self.work_dir, "yocto", "layers")
            layers = " ".join(_filter_yocto_core_layers(_flatten_layers(layers_node)))
            self.generator.build(layers_stamp,
                                 "yocto_add_layers",
                                 env_target,
                                 variables=dict(common_variables, layers=layers))

        # Next - update local.conf
        local_conf_target = os.path.join(self.yocto_dir, self.work_dir, "conf", "moulin.conf")
        local_conf_node = self.conf.get("conf", None)
        if local_conf_node:
            local_conf = _flatten_yocto_conf(local_conf_node)
        else:
            local_conf = []

        # Handle external sources (like build artifacts from some other build)
        local_conf.extend(self._get_external_src())

        # '$' is a ninja escape character so we need to quote it
        local_conf_lines = [
            shlex.quote(f'{k.replace("$", "$$")} = "{v.replace("$", "$$")}"') for k, v in local_conf
        ]

        self.generator.build(local_conf_target,
                             "yocto_update_conf",
                             layers_stamp if layers_node else env_target,
                             variables=dict(common_variables, conf=" ".join(local_conf_lines)))
        self.generator.newline()

        self.generator.build(f"conf-{self.name}", "phony", local_conf_target)
        self.generator.newline()

        # Next step - invoke bitbake. At last :)
        targets = self.get_targets()
        self.generator.build(targets,
                             "yocto_build",
                             local_conf_target,
                             variables=dict(common_variables,
                                            target=self.conf["build_target"].as_str,
                                            name=self.name))

        return targets

    def get_targets(self):
        "Return list of targets that are generated by this build"
        return [
            os.path.join(self.yocto_dir, self.work_dir, t.as_str)
            for t in self.conf["target_images"]
        ]

    def capture_state(self):
        """
        Update stored local conf with actual SRCREVs for VCS-based recipes.
        This should ensure that we can reproduce this exact build later
        """


def _env_prefix(yocto_dir: str, work_dir: str) -> str:
    """
    Return a shell snippet that cd's into yocto_dir and sources
    oe-init-build-env for work_dir.
    """
    return " && ".join([
        f"cd {yocto_dir}",
        f". poky/oe-init-build-env {work_dir}",
    ])


def _run_bash(cmd: str, *, capture=False) -> subprocess.CompletedProcess:
    """Run a bash -lc command."""
    return subprocess.run(
        ["bash", "-lc", cmd],
        check=True,
        capture_output=capture,
        text=capture,
    )


def rels_to_abs(base: Path, rels: List[str]) -> List[str]:
    return [str((base / rel).resolve(strict=False)) for rel in rels]


def handle_utility_call(conf, argv: List[str]) -> int:
    """
        Synchronize Yocto build layers with the specification from YAML.
        The function ensures that the active Yocto layers in a build directory
    match the layers defined in the YAML configuration. It uses a "stamp"
    file to detect if synchronization has already been performed.

    Workflow:

      1. If the stamp file does not exist:
         - Add all specified YAML layers to the build environment.
         - Create the stamp file.

      2. If the stamp file exists:
         - Run 'bitbake-layers show-layers' to read the
         - Normalize their paths and exclude Yocto core layers.
         - Compare "layers from argv (YAML)" vs "currently active layers."
         - If the sets differ -> remove extra layers and add missing ones.
    """

    # Parse CLI arguments
    parser = argparse.ArgumentParser(add_help=False)
    parser.add_argument("--yocto-dir", required=True)
    parser.add_argument("--work-dir", required=True)
    parser.add_argument("--layers", nargs="+", required=True)
    parser.add_argument("--stamp", required=True)
    args = parser.parse_args(argv)

    # Extract arguments into local variables
    layers = args.layers
    layers_str = " ".join(layers)
    yocto_dir = args.yocto_dir
    work_dir = args.work_dir
    stamp_out = args.stamp
    stamp_exists = Path(stamp_out).exists()
    env_prefix = _env_prefix(yocto_dir, work_dir)

    # Compute absolute build path
    work_dir_path = Path(work_dir)
    build_abs: Path = (
        work_dir_path if work_dir_path.is_absolute()
        else (Path(yocto_dir) / work_dir_path)).resolve(strict=False)

    # CASE 1: No stamp file yet -> add layers and create stamp
    if not stamp_exists:
        _run_bash(" && ".join([
            f"{env_prefix}",
            f"bitbake-layers add-layer {layers_str}",
            f"touch {stamp_out}",
        ]))
        return 0

    # CASE 2: Stamp exists -> check current state and sync if neededs
    # Run "bitbake-layers show-layers" to list currently active layers
    # Out of command for examle:
    #     layer                 path                             priority
    # ==========================================================================
    # meta                  /home/../../project/yocto/poky/meta  5
    # meta-poky             /home/../../project/yocto/poky/meta-poky  5
    # meta-yocto-bsp        /home/../../project/yocto/poky/meta-yocto-bsp  5
    # meta-virtualization   /home/../../project/yocto/meta-virtualization  8
    # meta-oe               /home/../../project/yocto/meta-openembedded/meta-oe  5
    # meta-filesystems      /home/../../project/yocto/meta-openembedded/meta-filesystems  5
    # meta-python           /home/../../project/yocto/meta-openembedded/meta-python  5
    # meta-networking       /home/../../project/yocto/meta-openembedded/meta-networking  5
    # ...and so on
    show_output = _run_bash(f"{env_prefix} && bitbake-layers show-layers", capture=True).stdout

    # Extract the 'path' column with regex
    row_re = re.compile(r"^[ \t]*#?[ \t]*\S+[ \t]+(?P<path>.+?)[ \t]+(?:\d+)[ \t]*$", re.MULTILINE)
    paths_only: List[str] = row_re.findall(show_output)

    # Canonicalize build layers path
    canonical_show_path = [str(Path(p).expanduser().resolve(strict=False)) for p in paths_only]

    # Get absolute paths for Yocto Core Layers lay
    yocto_core_layers_abs: List[str] = rels_to_abs(build_abs, YOCTO_CORE_LAYERS)

    # Get absolute paths for YAML-specified layers
    yaml_layers_abs: List[str] = rels_to_abs(build_abs, layers)

    # Filter out core layers to get only build-managed layers
    used_build_layers_abs = [p for p in canonical_show_path if p not in yocto_core_layers_abs]

    spec_layers_abs = yaml_layers_abs
    actual_layers_abs = used_build_layers_abs

    # Convert yaml layers and build layer lists into set
    spec_set = set(spec_layers_abs)
    actual_set = set(actual_layers_abs)

    # Determine which layers should be removed
    to_remove_abs = [p for p in actual_layers_abs if p not in spec_set]
    # Determine which layers should be added
    to_add_abs = [p for p in spec_layers_abs if p not in actual_set]

    # If there are layers to remove, otherwise empty string
    remove_cmd = ("bitbake-layers remove-layer " + " ".join(p for p in to_remove_abs)
                  if to_remove_abs else "")
    # If there are layers to add, otherwise empty string
    add_cmd = ("bitbake-layers add-layer " + " ".join(p for p in to_add_abs)
               if to_add_abs else "")
    # Always update the stamp file at the end
    touch_cmd = f"touch {stamp_out}"

    # Collect all command parts, skip empty ones, join with &&
    cmd_parts = [env_prefix, remove_cmd, add_cmd, touch_cmd]
    cmd = " && ".join(part for part in cmd_parts if part)

    _run_bash(cmd)
    return 0
